IDEALIZANDO TROCA DE TEMA: RESULTADO -> fundo escuro, mas ainda sendo possível ler o texto preto
- um botão que troca entre claro e escuro
	- dentro dele terá um script e ele receberá todos os textos e todos os objts q tiverem fundo q terá cor mudada
	- pro fundo, será trocado o material de referência, pro texto será a prop color
	- serão duas listas públicas: uma pra texto e outra pra objeto
		- qnd clicado, percorrerá um loop pra texto e um pra objt pra trocar a cor
		- nesse click, verificará a variável de controle... se vier true, é pra ligar o modo noturno, se vier false, modo claro
		- seria mais interessante os outros codes acessarem a var, pra daí n ficar mt objt e texto no msm code
	- eu qr esganar quem criou o text mesh pro
		- PQ?! ah pq acharam q seria uma ótima ideia por tags html pra definir a cor do texto (q ideia é essa mds?!!)
	- achei um jeito de mudar por code sem tag html, mas n reflete na tela a mudança de valor...
	- to trocando tds os tmp pra text dnv... (n sei pq no projeto tem os dois tipos sendo usados...)
	- falta trocar tema de props do poligono e spline, fazer eles serem arrastáveis, etc
	- talvez trocar a cor dos blocos tbm
	- trocar o tmp quebrou os inputfields... talvez pq o input continuou sendo do tipo tmp, talvez seja pq o tmp é um asset importado e por isso n troca de cor direito
	- criar um color gradient -> n funcionou
	- o tmp n troca de cor nem se eu abrir o inspect e colocar a cor q qr

FAZENDO PAINEL DE ARQUIVO:
-> fiz ele ficar visível, mas tá difícil de dimensional o botão pra um tamanho proporcional
-> consegui fazer os botões ficarem no tamanho
-> o botão de exportar é o mais simples, pq é só salvar oq foi feito... mas o de importar tem q abrir aqla janela de pesquisar arquivo, e tem q mostrar apenas os .json
	-> colocar caixa de texto para colar código e aí abertar em importar
-> tutorial bem enxuto, muito bom
-> preciso saber como q seria a estrutura da cena em json... olhar o projeto em threejs
-> ajeitei o json

	-> MONTANDO MEU CÓDIGO -> https://www.youtube.com/watch?v=C9WFOX6kDoo
	-> removi props q n existem no GRADE do arq json do visedu em threejs
	-> antes de começar a programar, importar como puglin o simplejson (joão passou o link no whats) (feito)
	-> "children" sempre vai ser um array json JSONArray()
	-> como fazer com props, q tem várias chaves?? vai ser um objeto json dentro de outro JSONObject()
	-> qual das listas/dicionários em Global é a que contém os nomes das peças? vou conseguir pegar as props tbm? ou vou importar os painéis de props e analisar os valores, assim como fiz no tutorial?
	-> começar pela exportação, vai ser mais tranquilo pq n vai precisar jogar na tela as peças, só dar um retorno q "foi exportado com sucesso!"
	-> qnd for importar, só pegar o conteúdo da caixa de texto e transformar ele em JSON, pra conseguir pegar as props e peças e tacar na tela
	-> "PARECE SIMPLES!"
	-> n aparece o renderer na cena salva, ele sempre tá lá, ent n precisa
	-> existe uma lista com todos os objetos em cena
	-> existe uma lista apenas com nomes de slots
	-> existe um dicionário q contém apenas os objetos que tiveram suas propriedades alteradas
	-> essa lista de objetos em cena, adiciona na ordem que EU coloco, não na ordem que aparece em cena (ou seja, n tem como saber quem é filho de quem)
	-> listaPosicaoObjetosRender NÃO MOSTRA ND, N IMPORTA QUÃO GRANDE SEJA A CENA
	-> listaEncaixes mostra qual objt da cena está em qual slot
	-> listLastGOTransformacoesSlot NÃO GUARDA ND
	-> listaPosicaoObjetosRender NÃO GUARDA ND
	-> propriedadeIluminacao -> dentro dela, tem o objt iluminação e uma lista com os outros objetos de cena e a iluminação dnv
	-> lightObjectList NÃO GUARDA ND
	-> PARA ACESSAR AS PROPS -> DENTRO DO CONTROLER, GO ABREPROPRIEDADE
		-> tem um controller dentro de cada peça da fábrica
	-> pensando aqui na gambi q vou ter q fazer (ou n) pra montar essa estrutura em json... (já q parece q n existe a estrutura para uma peça ser mãe de outra)
		PropriedadePeca prPeca = new PropriedadePeca();
                    prPeca.Nome = gameObject.name;
                    prPeca.PodeAtualizar = true;
                    prPeca.NomeCuboAmbiente = "CuboAmbiente" +...
                    prPeca.NomeCuboVis = "
	-> acessar a lista propriedadePecas, acessar as props via func (ler no code o nome delas) e pegar os valores, pronto
	-> essa func... createGameObjectTree... é uma mentira
	CRIAR NOVO CODE-> VAI SER ASSIM:
		
		-> toda vez q eu adicionar algum bloco, vou no msm instante adicionar ele no meu JSON, fica mais simples (daí rola ter children[])
		-> sobre as props... ainda tenho q ver mlr
		-> IDEIA: um code para kd tipo de peça-> se a tag for TAL, aí vai lá e acessa TAIS PROPS
		-> como acessar as props? dentro de kd code, vou tacar o painel de props e vou pegar elas de lá
		-> consigo acessar cada uma das props (menos cor e textura, ainda n sei como pegar elas)
		-> falta criar o lance de children
			-> VERIFICAR Y DAS PEÇAS... SE A PEÇA ESTIVER ENTRE UM OBJGRAF E OUTRO, ENT ELA É FILHA DO PRIMEIRO
			-> infelizmente, os objetos não são filhos NEM EM CENA, ent fica difícil de montar uma estrutura
			-> nem com a colisão rola, pq se eu remover a peça, continua na lista de children

			x de ObGrf -> 697; y-> 631
				cubo 628
				escalar 625
			x camera -> 696

			
TUTORIAL:
- mostrar como cada aba funciona (arquivo, fábrica, props, ajuda)
- mostrar o render, o ambiente e o visualizador
- regras para tutorial: https://tryevidence.com/blog/how-to-design-a-perfect-game-tutorial/
- exemplo tutorial: https://www.youtube.com/watch?v=a1RFxtuTVsk
- fazer tutorial breve e, dentro de cada peça qnd clicada, mostrar as props e um botão q explicará mlr aql componente
- pensei em criar um menu mlr na abertura, aí o usuário pode escolher entre "tutorial", "montar minha cena" ou "exercícios"
	- e aí em "exercícios" ele abre um outro menu com três opções de exercício
		- a cena de exercícios vai ser a principal só q com a flag de exercícios ativada, e com um botão de "verificar resposta", q daí vai retornar num painel quanto a pessoa acertou
	- dps q o tutorial acabar, ele redireciona pro "montar minha cena"
		- dentro do "montar minha cena", dentro da seção q agr está como "ajuda", terá como eu abri novamente o 		menu e ir pros exercícios

->>> NÃO ROLOU REFAZER O MENU, PQ DEU RUIM QND FUI TIRAR O MENU ANTIGO...

ATUALIZAR TEXT-MESH-PRO: JANELA WINDOW -> atualizei e nd mudou
	- coloquei o modo noturno numa cor q dá pra ler o texto preto
MOTAR TUTORIAL CONFORME REGRAS
CAMErA LOOK AT SEMPRE APONTANDO PRA Z E NEAR E FAR N FUNCIONAM NA CAMERA DE AMBIENTE
	-> descobri q tem um desenho q tem q atualizar, tenho q ver como acessar ele
	-> ainda n entendi pq o lookat todo tá apontando pra z
	-> como q o desenho atualiza no lookat, mas no near e far n?
	-> acho q tenho q mexer no moveambiente -> n!
	CameraGraf -> mostra o ambiente gráfico
	PosCameraObjt -> tem os desenhos de traço da câmera
	se o fov seria o scale, oq seria o far e near?
achei o desenho da câmera... mover o near e far desenhados só? pq na parte de baixo parece q funciona...
calculo pra near e far:
	https://jsfiddle.net/cZb66/3/
	https://www.youtube.com/watch?v=wFdvPuia5VM
	https://forum.unity.com/threads/how-do-i-get-the-world-coordinates-of-corners-of-far-clip-panel-of-camera-in-a-script.1360735/
	https://cursos.alura.com.br/forum/topico-duvida-nao-entendi-o-calculo-335678
	acho q esse: https://forum.unity.com/threads/how-to-get-the-actual-width-and-height-of-the-near-clipping-plane.72384/

	-> o problema do near e do far é q eles n estão dando retorno na parte de ambiente gráfico, apenas no visualizador
	-> o look at tá meio doido no ambiente gráfico
	-> pra ter retorno no ambiente gráfico, vai ter q mexer mt no CameraObjAmb
		-> parece ser algo mt trabalhoso pro pouco tempo q temos no momento, seria mlr dx de lado e voltar caso dê tempo
		-> por alguma razão, o look at parece se atualizar sozinho qnd mudo o ponto, mas o msm n acontece com far e near
		-> como o resultado desse esforço n vai retornar mts pontos, vou voltar nele qnd sobrar tempo, pq agr tenho q focar em algo q valha mais pra banca




EXPORTAR/IMPORTAR

eu tinha tido a ideia de pegar a posição dos slots pra fazer a peça ficar no lugar, mas infelizmente n rolou
por alguma razão o y do slot mandou a peça pra mt longe

o formaslot n muda de y durante a rolagem

acho q o negócio n é pegar a posição do slot, e sim gerar a peça na posição q o slot foi gerado
deu certo!!

problema na exportação: qnd vc n clica na peca pra ver as props, n é add na Global.propriedadePecas, aí complica de pegar as props certinhas

hmmm mas se eu n mudei as props, ent ele vai entrar no if q seta os valores padrão
tá, ent é checar se aquela chave existe e daí setar, blz -> deu certo!!

resolvido, mas ele adiciona (às vezes) no objeto errado, daí dá erro

no tutorial, qnd sem querer vou mt pra baixo com a peça da luz:
NullReferenceException: Object reference not set to an instance of an object
Controller.OnMouseUp () (at Assets/Scripts/Controller.cs:687)


// Verificar se o Objeto Gráfico pai está ativo para demonstrar o cubo.
                            string goObjGraficoSlot = GameObject.Find(Global.listaEncaixes[gameObject.name]).transform.parent.name;

-> as vezes as peças vao td pro primeiro slot de transf e as vezes o slot vai junto com elas pra algum lugar, sempre qnd peço pra abrir o painel de props
	-> agr as peças vão tudo pro primeiro slot só, n dá erro
	-> ou as peças ficam dançando pela tela ou ficam paradas numa posição q às vezes conhecide com um slot, e n abre props
	-> ARRUMEI, MAS ACHO Q PODE DAR PROBLEMA NA CONTAGEM AINDA... TEM Q DAR UM JEITO DE ARRUMAR ISSO
	-> o slot de ações n deixa adicionar maaaaaaaaaaais peças, mas tbm n precisaria num objt mais q uma de cada né...
	
-> achei um problema qnd eu crio uma cena com mais ações e vou clicando nas peças (tipo, trans rot esc trans rot...)... ele daí fica trocando a posição da peça (coisa q já tava implementada antes) e fica deixando aparecer apenas a props da vez no visualizador... ALÉM DE TROCAR NO NOME DOS SLOTS
	-> esse problema ocorre qnd estou apenas criando a cena...
	-> abri cada code modificado nos commits, não mexi em nada q fizesse o cubo do nada ficar só com uma ação por vez, ent acho q esse erro já tava

-> dá ruim qnd importo mais de um cubo, o nome do cubovis e cuboamb n tá certo... tenho q descobrir pq
	-> acho q faltou algo na hora de importar o cubo, aí n fez direito qnd repetia a peça

-> a câmera n parece começar com a posição importada...
-> a luz vem preta às vezes qnd n seta uma cor --> ainda n entendi como
-> verificação na exportação de cena vazia  -> arquivo linha 142
-> limpar cena na importação qnd n estiver vazia -> arquivo linha 948
-> problema pra importar cenas q começam com "cubo1"... fazer alguma verificação pra contornar o erro na chave -> arquivo linha 327
	-> n dá mais erro, mas as props do cubo não são importadas (props tamanho e posicao)
		-> se pegar outra peça q já tá na tela, dá ruim pq ficam as duas com "1" no nome, por exemplo
		-> a solução é converter o nome pra "cubo", qnd já começa assim
		-> oq seriam mlr... fazer isso na exportação ou na importação?
			-> acho q exportação... pq daí ele vai adicionar em ordem, aí se eu to com o "Cubo1", eu checo se existe um "Cubo"
			-> se existir, ent quer dizer q ele só tá mais pra baixo na cena, senão ele não existe, e aí eu converto o nome, e vou fazendo isso
				-> checar se nomePeca é maior q 4 e pegar a posição nomePeca[nomePeca.Length-1] e converter pra int
				-> aí se for 1, remove ele e checa se existe ou n
				-> se for maior q 1, é só subtrair e checar se existe ou n

					-> ainda dá erro na linha 312 do arquivo e na 90 do propcubopadrao
			-> no caso da câmera e da luz, n precisa pq só aparece uma vez na cena
			-> mas nos outros é importante, só n vai dar erro se n repetir a peça em cena
	-> e as props n aparecem no painel
	-> aí as peças de ação n funcam, pq n tem tam e pos no cubo







 var nome = "Rotacionar";
                    var nomeSlot = "TransformacoesSlot";
                    if (countAcoes > 0) nomeSlot += "_" + countAcoes;
                    if (countRot > 0) nome += countRot;

                    print(nomeSlot);
                    var rotacionar = GameObject.Find(nome);
                    var controller = rotacionar.GetComponent<Controller>();
                    controller.GeraCopiaPeca();

                    float y = GameObject.Find(nomeSlot).gameObject.transform.position.y;
                    //pegar nome prefab + numero e mudar posicao
                    rotacionar.transform.position = new Vector3(x, y, z); //TÁ COM PROBLEMAS NO Y!!!!!!!!!
                    rotacionar.GetComponent<BoxCollider>().enabled = true;
                    Global.addObject(rotacionar);

                    Global.atualizaListaSlot();
                    //TEM Q ADICIONAR NA LISTA DE ENCAIXES!!!!!!!!!!!
                    adicionarEncaixe(rotacionar);

                    var slotNome = "ObjGraficoSlot";
                    if (countObjt > 0) slotNome += countObjt;
                    GameObject ObjGrafSlot = GameObject.Find(slotNome);

                    //Retorna  de TransformacoesSlot
                    string slot = "";

                    for (int i = 0; i < ObjGrafSlot.transform.childCount; i++)
                    {
                        if (ObjGrafSlot.transform.GetChild(i).name.Contains("TransformacoesSlot"))
                        {
                            if (Global.listaEncaixes.ContainsValue(ObjGrafSlot.transform.GetChild(i).name))
                            {
                                slot = ObjGrafSlot.transform.GetChild(i).name;
                            }
                        }
                    }

                    int val = 0;
                    string countTransformacoes = "";
                    Int32.TryParse(slot.Substring(slot.IndexOf("_") + 1), out val);

                    if (val > 0)
                        countTransformacoes = Convert.ToString(val + 1);
                    else
                        countTransformacoes = "1";
                    //-------------
                    countAcoes++;
                    print(nomeSlot);
                    GameObject t = GameObject.Find(nomeSlot);
                    GameObject cloneTrans = Instantiate(t, t.transform.position, t.transform.rotation, t.transform.parent);
                    if (countAcoes > 0) cloneTrans.name = "TransformacoesSlot_" + countAcoes;
                    else cloneTrans.name = "TransformacoesSlot_1";
                    cloneTrans.transform.position = new Vector3(t.transform.position.x, t.transform.position.y - 3f, t.transform.position.z);

                    controller.addTransformacoeSequenciaSlots(cloneTrans.name);

                    controller.posicaoColliderDestino = t;

                    if (controller.renderController == null)
                        controller.renderController = new RenderController();

                    controller.renderController.ResizeBases(t, Consts.Transladar, true); // o Segundo parâmetro pode ser qualquer tranformação 

                    controller.addGameObjectTree("GameObjectAmb" + controller.getNumeroSlotObjetoGrafico(), "Amb", "CuboAmbiente" + controller.getNumeroSlotObjetoGrafico());
                    controller.addGameObjectTree("CuboVisObject" + controller.getNumeroSlotObjetoGrafico(), "Vis", "CuboVis" + controller.getNumeroSlotObjetoGrafico());

                    controller.configuraIluminacao("-");

                    if (countObjt == 0) controller.reorganizaObjetos("");
                    else controller.reorganizaObjetos(countObjt.ToString());

                    setPropsAcoes(controller, value, countObjt, nome);
                    Global.atualizaListaSlot();
                    countRot++;